#!/usr/bin/env python
'''
##  Read binary files and generate C header  ##

'''

import sys;
import os;
import argparse;

VERSION = '0.1.0';
FILE = os.path.basename(sys.argv[0]);

'''
Parse arguments using argparse

Arguments rusults stored in args object.

[file]   args.files			array of files to read from
file     args.outFileName	file to write output to
string   args.mode			mode to open output file with (either append or write)
bool     args.comment		whether to print comments on each line of hexdump
'''
defaultout = 'out.dump';
defaultCout = 'out.h';

parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
	description=
	'Creates a C file from the contents of each file. ' "\n"
	'Files are embedded as variables named afer the file name.',
	epilog=' ')

parser.add_argument('files', metavar='file', type=str, nargs='+',
					help='A file to be embedded')

parser.add_argument('-o', '--out', metavar='file', dest='outFileName', type=str, nargs='?',
					help='The name of the file to output into. (default: %s)' % defaultout)

parser.add_argument('-a', '--apend', dest='mode', action='store_const',
					const='a', default='w', # mode to open output file
					help='Append into OutputFile (default: overrite origional)')

parser.add_argument('-c', '--out-c', dest='c', action='store_true',
					help='Generate a C file embedding as C strings. (changes default -o to %s)' % defaultCout)

parser.add_argument('-n', '--no-comment', dest='comment',
					action='store_false',
					help='Disables outputting readable line comments at the end of each row (default: false)')

parser.add_argument('-l', '--length', metavar='N', dest='length', type=int, default=10,
					help='The number of bytes to write per line. (default: 10)')

parser.add_argument('-s', '--style', metavar='style', dest='style',
					choices=['u', 'up', 'upper', 'uppercase',
							'l', 'lo', 'low', 'lower', 'lowercase', 
							'c', 'ca', 'cap', 'capital', 'capitalize',
							'n', 'no', 'nochange'], default='n',
					help='Apply style to generated variable names. You may use the most significant parts (e.g. \'u\', \'up\' or \'upper\') (default: no)  \n'
					'Choices: uppercase, lowercase, capitalize, no)')

parser.add_argument('-v', '--version', action='version', version='%s %s' % (FILE, VERSION))

args = parser.parse_args()

if (not args.outFileName):
	if (args.c): args.outFileName = defaultCout;
	else: args.outFileName = defaultout

def match_str_transform(argument, string):
	switcher = {
		'c': string.capitalize(),
		'u': string.upper(),
		'l': string.lower(),
	}
	return switcher.get(argument[0], string)

def main():
	## Add all var names to an arry for use in the other loops
	varnames = [];
	for inFileName in args.files:
		varnames.append(
			match_str_transform(
				args.style, genVarName(inFileName)
			)
		);

	## Check for duplicated varnames
	dupes = list_duplicates(varnames);
	if (len(dupes) > 0):
		sys.stderr.write('Error: The following variable names were generated more than once.\n'
					'        ');
		i = 0;
		for dup in dupes:
			sys.stderr.write('\'%s\', ' % dup);
			# Newline every 5 chars
			i += 1;
			if (i == 5):
				i = 0;
				sys.stderr.write('\n        ');
		sys.stderr.write(
			'\n      To fix this you need to rename the source files you wish to generate'
			'\n      Special characters will be replaced with underscores and'
			'\n      trimmed to avoid repeated underscores\n');
		sys.exit(1);
	
	if (args.c):
		print ('Writing C file into %s\n' % args.outFileName);
	else:
		print ('Writing into %s\n' % args.outFileName);
	

	with open(args.outFileName, 'w') as outfile:
		if (args.c):
			filedef = '_' + genVarName(args.outFileName).upper();
			# C file header
			outfile.write(
				'/*\n * %s\n *\n' # Title
				' * This file was automatically generated by %s\n' # Info
				' * \n'
				' * The following variables are included in this file, along with a size_t varname_LEN:\n'
				' * \n'
				' *  ' % (args.outFileName, FILE));
			i = 0;
			while (i < len(args.files)):
				# List Each varname
				outfile.write('\'%s\'' % varnames[i])
				
				# end comment/heading after final varname
				if(i == len(args.files) - 1):
					outfile.write('\n *\n */\n\n')
				# Cap line at 5 prints
				elif(i % 5 == 0 and i > 0):
					outfile.write('\n *  ');
				# if second last on line
				elif(( i == len(args.files) - 2 )):
					outfile.write(' and ');
				else:
					outfile.write(', ');
				
				i += 1;

			outfile.write(
				'#ifndef %s\n'
				'#define %s\n'
				'#include <stdlib.h>\n\n'
				% (filedef, filedef));

		## Iterate over files and dump their bytes into the outfile
		i = 0;
		for inFileName in args.files:
			# bytecount reset for each file
			bytecount = 0;
			
			
			outfile.write('/* generated from %s */\n' % (inFileName));
			if (args.c):
				outfile.write('unsigned char %s[] = {\n' % varnames[i]);

			with open(inFileName, 'rb') as infile:
				print ('Reading data from %s' % inFileName)
				bytecount = hexdump(outfile, infile, length=args.length, comment=args.comment);

			if (args.c):
				outfile.write('};\n');
				outfile.write('size_t %s_LEN = %d;\n' % (varnames[i], bytecount));
			outfile.write('\n')
			
			i += 1; # Keep track of which file we are on

	
	## Give the user some friendly feedback
	print ('\nThe following files were embedded into \'%s\'' % args.outFileName);
	i = 0;
	while (i < len(args.files)):
		if (args.c):
			print ('    \'%s\' as' % args.files[i]);
			print ('            \'unsigned char %s[]\'' % varnames[i]);
			print ('        and \'size_t %s_LEN\'' % varnames[i]);
		else:
			print ('    \'%s\'' % args.files[i]);
		i += 1;


'''
@brief	Generate a pretty C variable name from input
@param[in]	src		{Str}	string to be converted to C variabe name
@return		varName	{Str}	A valid C variable name with no double, leading or trailing underscores
'''
def genVarName (src):
	x = 0; # varname iterator, increase only when we write to varname
	i = 0; # loop/src iterator, increase every time we read from src
	varname = ''; # Output string
	
	# Ensure first char is a capital letter (not number or _)
	while (x==0 and i < len(src)):
		if (src[i].isalpha()):
			varname += src[i];
			# increase x on success
			x += 1;
		# increase i each time we check
		i += 1;
	
	# Loop over the rest
	while (i < len(src)):
		# copy letters and numbbers in upper case
		if (src[i].isalnum()):
			varname += src[i];
			x += 1;
		# Convert other chars to _ (unless prev char is _)
		elif (not varname[x-1] == '_'):
			varname += '_';
			x += 1;
		# increase i on every check
		i += 1;
	
	# Trim underscores from end of varname
	varname = varname.strip('_');
	
	# error if empty
	if (len(varname) == 0):
		sys.stderr.write('Error: genVarName(%s) produced empty string\n' % src);
		sys.exit(1);
	return varname;


'''
@brief Return {NumBytes} written to {outfile}.
@param[out] outfile		{File} Open file in which to write to (reuired)
@param[in]  srcfile		{File} File to read from (required)
@param[in]  length	{Int}  Number of bytes per row. (default 16)
@param[in]  sep		{Char} For the comment part, {sep} will be used for non ASCII char. (default .)
@param[in]  comment  {Bool} Toggle including the line comments (default true)
@return {Int} Number of bytes written

@note Full support for python2 and python3 !
'''
def hexdump( outfile, srcfile, length=16, sep='.', comment=True ):
	# Python3 support
	try: xrange(0,1);
	except NameError: xrange = range;
	
	if (not srcfile): 
		sys.stderr.write("Error: hexdump requires argument \"srcfile\"\n")
		sys.exit(1)
	if (not outfile): 
		sys.stderr.write("Error: hexdump requires argument \"outfile\"\n")
		sys.exit(1)
	
	# Begin
	
	# bytecount keeps track of the total bytes read/pretty-printed
	# we return this at the end
	bytecount = 0;
	# subSrc is our buffer/chunk of srcfile and line is the current line used to write a pretty output
	# subSrc and line are reset and reused for each line.
	# one line equals one chunk 
	subSrc = srcfile.read(length);
	line = ''
	
	# Loop over lines (byte range of length)
	while subSrc: # Break when subSrc becomes empty
		
		# Loop over bytes
		for h in xrange(0,len(subSrc)):
			# Extra space in the middle column
			if h == length/2: line += ' ';
			
			# Reuse h as byte from subSrc
			h = subSrc[h];
			if not isinstance(h, int):
				h = ord(h);
			h = hex(h).replace('0x','');
			if len(h) == 1: h = '0' + h;
			line += '0x' + h + ', ';
			
			# Increment total bytecount
			bytecount += 1;
		
		# Add a readable hexdump as a comment
		if (comment):
			mod = bytecount % length;
			if (mod > 0):
				# This is the last line, and it is less than the full size
				# Add spaces so that the comment aligns correctly
				if (mod > (length / 2)):
					# Half way column has an extra space
					# Add one if printed bytes is less than half the line length
					line += ' ';
				# Add a 6 spaces for every missing byte.
				# (each byte is 4 numbers, one comma and one space)
				line += ' ' * (6 * (length - mod) -1);
				
			line += ' // ';
			# Add ASCI bytes using chr(), represent others with sep (default '.')
			for c in subSrc:
				if not isinstance(c, int):
					c = ord(c);
				if 0x20 <= c < 0x7F:
					line += chr(c);
				else:
					line += sep;

			if (mod > (length / 2)):
				# Add extra spaces to end of comment so all lines are the same length
				line += ' ' * (length - mod);
		
		# Append the line
		outfile.write('    ' + line + '\n');
		
		# Reset line vars
		subSrc = srcfile.read(length)
		line = '';
	
	return bytecount;

def list_duplicates(seq):
	seen = set()
	seen_add = seen.add
	# adds all elements it doesn't know yet to seen and all other to seen_twice
	return set( x for x in seq if x in seen or seen_add(x) )

# Run main
main()
